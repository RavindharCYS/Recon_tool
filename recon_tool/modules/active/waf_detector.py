"""
WAF (Web Application Firewall) Detector Module.
Attempts to identify WAF presence by sending various HTTP requests and analyzing responses.
Note: WAF detection is heuristic and can be unreliable or trigger alerts. Use responsibly.
"""
import requests
import logging
import re
import time
import random
import string # For generating random strings
from typing import Dict, List, Any, Optional, Union, Tuple # Added Tuple
from urllib.parse import urlparse, urljoin

from ...config import DEFAULT_USER_AGENT, DEFAULT_TIMEOUT, DEFAULT_DELAY, QUICK_TIMEOUT # UPDATED
from ...utils.validators import is_valid_url, is_valid_domain # UPDATED
# from ...utils.network_helpers import get_ip_from_domain # Not directly used here

logger = logging.getLogger(__name__)

# --- WAF Signatures (Headers, Cookies, Content) ---
# This list can be expanded significantly.
# Patterns are regex. Case-insensitive matching is often applied.
# 'type' can be 'header', 'cookie', 'html_content', 'status_code_block'
WAF_FINGERPRINTS: Dict[str, List[Dict[str, Any]]] = {
    "Cloudflare": [
        {"type": "header", "name": "Server", "pattern": r"cloudflare"},
        {"type": "header", "name": "CF-RAY", "pattern": r".+"}, # Presence of cf-ray header
        {"type": "cookie", "name": "__cfduid", "pattern": r".+"}, # Older, might still see
        {"type": "cookie", "name": "cf_clearance", "pattern": r".+"},
        {"type": "html_content", "pattern": r"Cloudflare Ray ID:|cdnjs\.cloudflare\.com|Attention Required! \| Cloudflare"},
        {"type": "status_code_block", "codes": [403, 503], "html_pattern": r"cloudflare", "reason": "Blocked by Cloudflare policy"}
    ],
    "AWS WAF": [
        {"type": "header", "name": "Server", "pattern": r"awselb|aws-elb"}, # Often behind ELB
        {"type": "header", "name": "x-amzn-waf-action", "pattern": r".+"},
        {"type": "header", "name": "x-amz-cf-id", "pattern": r".+"}, # CloudFront often used with WAF
        {"type": "html_content", "pattern": r"AWS WAF|cloudfront"},
        {"type": "status_code_block", "codes": [403], "html_pattern": r"cloudfront", "reason": "Blocked by AWS WAF/CloudFront"}
    ],
    "Akamai (Kona Site Defender)": [
        {"type": "header", "name": "Server", "pattern": r"AkamaiGHost"},
        {"type": "header", "name": "X-Akamai-Transformed", "pattern": r".+"},
        {"type": "html_content", "pattern": r"akamaitechnologies\.com| अक्षम"}, # "Akamai Technologies" or Devanagari for "Access Denied"
        {"type": "status_code_block", "codes": [403, 400], "html_pattern": r"akamai|reference error #", "reason": "Blocked by Akamai policy"}
    ],
    "Imperva Incapsula": [
        {"type": "header", "name": "X-Iinfo", "pattern": r".+"},
        {"type": "cookie", "name": r"incap_ses_", "pattern": r".+"}, # Starts with incap_ses_
        {"type": "html_content", "pattern": r"incapsula\.com|Request unsuccessful"},
        {"type": "status_code_block", "codes": [403, 401], "html_pattern": r"incapsula", "reason": "Blocked by Imperva Incapsula"}
    ],
    "Sucuri CloudProxy": [
        {"type": "header", "name": "Server", "pattern": r"Sucuri/Cloudproxy"},
        {"type": "header", "name": "X-Sucuri-ID", "pattern": r".+"},
        {"type": "header", "name": "X-Sucuri-Cache", "pattern": r".+"},
        {"type": "html_content", "pattern": r"sucuri\.net|ถูกบล็อก"}, # "Blocked" in Thai
        {"type": "status_code_block", "codes": [403], "html_pattern": r"sucuri|cloudproxy", "reason": "Blocked by Sucuri CloudProxy"}
    ],
    "F5 BIG-IP ASM": [
        {"type": "header", "name": "Server", "pattern": r"BigIP|BIG-IP"},
        {"type": "cookie", "name": r"BIGipServer", "pattern": r".+"}, # Starts with BIGipServer
        {"type": "cookie", "name": r"TS[0-9a-fA-F]+", "pattern": r".+"}, # TS cookie, e.g. TS012345ab
        {"type": "html_content", "pattern": r"The requested URL was rejected\. Please consult with your administrator\."},
        {"type": "status_code_block", "codes": [403], "html_pattern": r"support id:|big-ip|asm support id", "reason": "Blocked by F5 BIG-IP ASM"}
    ],
    "ModSecurity": [
        # Server header often reveals it, but can be hidden.
        # ModSecurity often returns 403, 406, or 501 on malicious requests.
        # Block pages might contain "Mod_Security" or "mod_security" or "Not Acceptable!"
        {"type": "header", "name": "Server", "pattern": r"mod_security|Mod_Security"},
        {"type": "status_code_block", "codes": [403, 406, 501], "html_pattern": r"mod_security|not acceptable!", "reason": "Potentially blocked by ModSecurity"}
    ],
    "Wordfence": [
        {"type": "html_content", "pattern": r"Generated by Wordfence| umani?"}, # "Blocked by Wordfence" or "You are human?"
        {"type": "status_code_block", "codes": [403, 503], "html_pattern": r"wordfence", "reason": "Blocked by Wordfence"}
    ],
    "FortiWeb": [
        {"type": "cookie", "name": r"FORTIWAFSID", "pattern": r".+"},
        {"type": "status_code_block", "codes": [403], "html_pattern": r"fortiweb|fgd_icon", "reason": "Blocked by FortiWeb"}
    ],
    "Barracuda WAF": [
        {"type": "cookie", "name": r"barra_counter_session", "pattern": r".+"},
        {"type": "cookie", "name": r"BNI_persistence", "pattern": r".+"},
        {"type": "status_code_block", "codes": [403], "html_pattern": r"barracuda", "reason": "Blocked by Barracuda WAF"}
    ],
     "Citrix NetScaler AppFirewall": [ # Added (more specific than generic NetScaler)
        {"type": "cookie", "name": r"citrix_ns_id|NSC_", "pattern": r".+"},
        {"type": "header", "name": "Cneonction", "pattern": r"close"}, # Deliberate typo sometimes seen
        {"type": "header", "name": "Location", "pattern": r"/vpn/index\.html"}, # On block
        {"type": "status_code_block", "codes": [403], "html_pattern": r"citrix|netscaler", "reason": "Blocked by Citrix NetScaler"}
    ]
}

# Payloads for behavioral tests (benign and slightly malicious)
# These should be chosen carefully to be indicative but not harmful.
BEHAVIORAL_TEST_PAYLOADS: List[Dict[str, Any]] = [
    {"name": "Benign", "path": "/", "params": {}, "headers": {}},
    {"name": "Common XSS Probe", "path": "/", "params": {"q": "<script>alert('WAF_TEST')</script>"}, "headers": {}},
    {"name": "Common SQLi Probe", "path": "/", "params": {"id": "1' OR '1'='1"}, "headers": {}},
    {"name": "Path Traversal Probe", "path": "/../../../../etc/passwd", "params": {}, "headers": {}},
    {"name": "Malicious User-Agent", "path": "/", "params": {}, "headers": {"User-Agent": "sqlmap/1.5.5 (http://sqlmap.org)"}},
    {"name": "LFIC Probe", "path": "/", "params": {"file": "php://filter/convert.base64-encode/resource=index.php"}, "headers": {}},
    {"name": "Command Injection Probe", "path":"/", "params": {"cmd": "cat /etc/passwd"}, "headers": {}}
]


def _make_request(url: str, method: str = "GET", params: Optional[Dict[str, str]] = None, 
                  data: Optional[Dict[str, str]] = None, headers: Optional[Dict[str, str]] = None, 
                  timeout: float = QUICK_TIMEOUT) -> Tuple[Optional[requests.Response], Optional[str]]:
    """Helper to make an HTTP request and handle common exceptions."""
    req_headers = {"User-Agent": DEFAULT_USER_AGENT}
    if headers:
        req_headers.update(headers)
    
    try:
        response = requests.request(method, url, params=params, data=data, headers=req_headers, 
                                    timeout=timeout, allow_redirects=True, verify=True) # verify=True is default but explicit
        return response, None
    except requests.exceptions.Timeout:
        return None, "Timeout"
    except requests.exceptions.ConnectionError:
        return None, "Connection error"
    except requests.exceptions.RequestException as e:
        return None, f"Request exception: {type(e).__name__}"


def detect(target_url_str: str) -> Dict[str, Any]: # Renamed target to target_url_str
    """
    Detects if a website at target_url is protected by a WAF.
    Combines signature-based and behavioral analysis.
    """
    logger.info(f"Starting WAF detection for: {target_url_str}")

    if not is_valid_url(target_url_str):
        parsed_check = urlparse(target_url_str)
        if not parsed_check.scheme and parsed_check.netloc:
            target_url_str = "https://" + target_url_str
        elif not parsed_check.scheme and not parsed_check.netloc and is_valid_domain(target_url_str):
            target_url_str = "https://" + target_url_str
        else:
            logger.error(f"Invalid URL format for WAF detection: {target_url_str}")
            return {"target_url": target_url_str, "error": "Invalid URL format."}

    detection_result: Dict[str, Any] = { # Renamed result to detection_result
        "target_url": target_url_str,
        "waf_detected": False,
        "identified_waf_name": None,
        "detection_methods": [], # e.g., ['signature_header', 'behavioral_block']
        "confidence_score": 0, # 0-100
        "evidence": [], # List of strings or dicts explaining findings
        "initial_response_status": None,
        "blocked_payloads_count": 0
    }

    # 1. Initial Benign Request & Signature Check
    logger.debug(f"Performing initial benign request to {target_url_str}")
    response_initial, error_initial = _make_request(target_url_str, timeout=DEFAULT_TIMEOUT)

    if error_initial or not response_initial:
        detection_result["error"] = f"Initial request failed: {error_initial or 'No response'}"
        return detection_result
    
    detection_result["initial_response_status"] = response_initial.status_code
    
    # Signature-based detection from initial response
    for waf_name, signatures in WAF_FINGERPRINTS.items():
        for sig in signatures:
            if sig["type"] == "header":
                header_val = response_initial.headers.get(sig["name"])
                if header_val and re.search(sig["pattern"], header_val, re.IGNORECASE):
                    detection_result["waf_detected"] = True
                    detection_result["identified_waf_name"] = waf_name
                    detection_result["detection_methods"].append("signature_header")
                    detection_result["evidence"].append(f"Header '{sig['name']}: {header_val}' matches {waf_name} pattern.")
                    detection_result["confidence_score"] = max(detection_result["confidence_score"], 80) # High confidence for direct header match
            elif sig["type"] == "cookie":
                for cookie in response_initial.cookies:
                    if re.search(sig["name"], cookie.name, re.IGNORECASE) and \
                       re.search(sig["pattern"], cookie.value, re.IGNORECASE):
                        detection_result["waf_detected"] = True
                        detection_result["identified_waf_name"] = waf_name
                        detection_result["detection_methods"].append("signature_cookie")
                        detection_result["evidence"].append(f"Cookie '{cookie.name}' matches {waf_name} pattern.")
                        detection_result["confidence_score"] = max(detection_result["confidence_score"], 75)
            elif sig["type"] == "html_content":
                # Limit HTML check to avoid performance issues on large pages
                if re.search(sig["pattern"], response_initial.text[:10000], re.IGNORECASE | re.DOTALL):
                    detection_result["waf_detected"] = True
                    detection_result["identified_waf_name"] = waf_name
                    detection_result["detection_methods"].append("signature_html")
                    detection_result["evidence"].append(f"HTML content matches {waf_name} pattern: '{sig['pattern']}'.")
                    detection_result["confidence_score"] = max(detection_result["confidence_score"], 70)
        
        if detection_result["waf_detected"] and detection_result["identified_waf_name"] == waf_name:
             logger.info(f"Signature match for {waf_name} from initial response.")
             # Could break early if high confidence, or continue for more evidence

    # 2. Behavioral Tests (Sending probes)
    # Only proceed if WAF not already identified with high confidence or if user wants full check
    if detection_result["confidence_score"] < 90: # Threshold for performing behavioral tests
        logger.info("Performing behavioral WAF detection tests.")
        for payload_test_case in BEHAVIORAL_TEST_PAYLOADS: # Renamed payload to payload_test_case
            test_name = payload_test_case["name"]
            # Construct URL for GET requests with params
            test_target_url = urljoin(target_url_str, payload_test_case["path"]) # Use urljoin for paths
            
            # Add random string to params to try and bypass caching
            current_params = payload_test_case.get("params", {}).copy()
            current_params[f"_{random.randint(1000,9999)}"] = "".join(random.choices(string.ascii_lowercase, k=5))

            logger.debug(f"Sending behavioral test: '{test_name}' to {test_target_url} with params {current_params}")
            time.sleep(DEFAULT_DELAY / 2) # Small delay between probes

            response_probe, error_probe = _make_request(test_target_url, params=current_params, headers=payload_test_case.get("headers"))

            if error_probe or not response_probe:
                detection_result["evidence"].append(f"Behavioral test '{test_name}' failed: {error_probe or 'No response'}")
                continue

            # Analyze probe response
            # A significant change from initial benign response can indicate WAF
            # Common WAF block status codes: 403, 406, 418, 429, 503 (sometimes)
            blocked_status_codes = [403, 406, 418, 429, 500, 501, 503] 
            if response_probe.status_code in blocked_status_codes and \
               (response_initial is None or response_probe.status_code != response_initial.status_code): # Ensure it's different from initial
                
                detection_result["blocked_payloads_count"] += 1
                detection_result["waf_detected"] = True
                detection_result["detection_methods"].append(f"behavioral_block_{test_name.lower().replace(' ','_')}")
                evidence_msg = (f"Test '{test_name}' resulted in status {response_probe.status_code} "
                                f"(Initial: {detection_result['initial_response_status']}).")
                detection_result["evidence"].append(evidence_msg)
                detection_result["confidence_score"] = max(detection_result["confidence_score"], 60) # Moderate confidence for generic block

                # Try to identify WAF from block page content
                for waf_name_bhv, signatures_bhv in WAF_FINGERPRINTS.items(): # Renamed
                    for sig_bhv in signatures_bhv: # Renamed
                        if sig_bhv["type"] == "status_code_block" and response_probe.status_code in sig_bhv["codes"]:
                            if re.search(sig_bhv["html_pattern"], response_probe.text[:5000], re.IGNORECASE | re.DOTALL):
                                detection_result["identified_waf_name"] = waf_name_bhv
                                detection_result["evidence"][-1] += f" Block page content matches {waf_name_bhv} ({sig_bhv['reason']})."
                                detection_result["confidence_score"] = max(detection_result["confidence_score"], 90) # High confidence
                                logger.info(f"Behavioral block for '{test_name}' identified as {waf_name_bhv}.")
                                break # Found specific WAF from block page
                    if detection_result["identified_waf_name"] == waf_name_bhv: break # Move to next test case

    # Final confidence adjustment based on number of indicators
    if len(detection_result["detection_methods"]) > 1:
        detection_result["confidence_score"] = min(100, detection_result["confidence_score"] + 10 * (len(detection_result["detection_methods"]) -1) )
    if detection_result["blocked_payloads_count"] > 2: # Multiple blocks are a strong indicator
         detection_result["confidence_score"] = min(100, detection_result["confidence_score"] + 15)


    if not detection_result["waf_detected"]:
        logger.info(f"No definitive WAF signatures or behaviors detected for {target_url_str}.")
        detection_result["evidence"].append("No common WAF signatures or blocking behaviors were detected.")
    else:
        logger.info(f"WAF detection for {target_url_str}: Name='{detection_result['identified_waf_name']}', Confidence={detection_result['confidence_score']}%")

    return detection_result

